<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>悬疑风格弹窗效果</title>
  <!-- 引入Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- 引入Font Awesome -->
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <!-- 配置Tailwind -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            glitch: '#00ff9d',
            danger: '#ff0066',
            dark: '#0a0a0a',
            darker: '#050505',
            terminal: '#0f1912'
          },
          fontFamily: {
            mono: ['Courier New', 'monospace'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .text-shadow-glitch {
        text-shadow: 0 0 5px theme('colors.glitch'), 
                     0 0 10px theme('colors.glitch/70');
      }
      .text-shadow-danger {
        text-shadow: 0 0 5px theme('colors.danger'), 
                     0 0 10px theme('colors.danger/70');
      }
      .border-glow {
        box-shadow: 0 0 5px theme('colors.glitch'),
                    0 0 10px theme('colors.glitch/50');
      }
      .scanline {
        background: linear-gradient(to bottom, 
                    rgba(255,255,255,0) 0%,
                    rgba(255,255,255,0.2) 50%,
                    rgba(255,255,255,0) 100%);
        position: absolute;
        width: 100%;
        height: 6px;
        animation: scan 2s linear infinite;
      }
      .tv-flicker {
        animation: tvFlicker 0.1s infinite alternate;
      }
      .fade-out {
        animation: fadeOut 0.3s forwards;
      }
      .crt-shutdown {
        animation: crtShutdown 1.8s forwards; /* 延长CRT关闭动画时间 */
      }
      .fade-in {
        animation: fadeIn 0.5s forwards;
      }
      .pulse-soft {
        animation: pulseSoft 2s infinite alternate;
      }
      .static-overlay {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.3'/%3E%3C/svg%3E");
        background-repeat: repeat;
      }
      .button-shake {
        animation: buttonShake 0.5s cubic-bezier(.36,.07,.19,.97) both;
      }
      .text-fade-in {
        animation: textFadeIn 0.5s forwards;
      }
      .message-appear {
        animation: messageAppear 0.6s forwards;
      }
    }
    
    @keyframes scan {
      0% { top: -10%; }
      100% { top: 100%; }
    }
    
    @keyframes tvFlicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
      70% { opacity: 0.9; }
      90% { opacity: 0.6; }
    }
    
    @keyframes fadeOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    
    @keyframes crtShutdown {
      0% { 
        opacity: 1; 
        transform: scale(1);
        filter: brightness(1);
      }
      50% { 
        opacity: 0.8;
        filter: brightness(1.2);
      }
      100% { 
        opacity: 0; 
        transform: scale(0.95);
        filter: brightness(0) blur(2px);
      }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    
    @keyframes pulseSoft {
      from { box-shadow: 0 0 10px theme('colors.glitch/50'); }
      to { box-shadow: 0 0 20px theme('colors.glitch/80'); }
    }
    
    @keyframes buttonShake {
      10%, 90% { transform: translateX(-1px); }
      20%, 80% { transform: translateX(2px); }
      30%, 50%, 70% { transform: translateX(-3px); }
      40%, 60% { transform: translateX(3px); }
    }
    
    @keyframes textFadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes messageAppear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body class="bg-black min-h-screen overflow-hidden font-mono text-glitch relative">
  <!-- 多重扫描线效果 -->
  <div class="scanline"></div>
  <div class="scanline" style="animation-delay: 0.5s;"></div>
  <div class="scanline" style="animation-delay: 1s;"></div>
  
  <!-- 增强的无信号噪点效果 -->
  <div class="fixed inset-0 static-overlay pointer-events-none tv-flicker"></div>
  <div class="fixed inset-0 bg-gradient-to-b from-black/30 via-transparent to-black/60 pointer-events-none"></div>
  
  <!-- 弹窗容器 -->
  <div id="popup-container" class="relative w-full h-screen"></div>
  
  <!-- CRT关闭效果覆盖层 (初始隐藏) -->
  <div id="crt-overlay" class="fixed inset-0 bg-black opacity-0 pointer-events-none transition-opacity duration-800 z-40"></div>
  
  <!-- 最终选择框容器 (初始隐藏) -->
  <div id="final-choice-container" class="fixed inset-0 flex items-center justify-center z-50 opacity-0 pointer-events-none transition-opacity duration-1000">
    <div class="w-full max-w-md p-6 bg-terminal border-2 border-glow pulse-soft" style="border-radius: 0;">
      <div class="mb-2 pb-2 border-b border-glitch/30">
        <h2 class="text-glitch text-shadow-glitch text-lg">连接请求</h2>
        <p class="text-xs text-glitch/80">未知设备 #7391 正在尝试建立连接</p>
      </div>
      
      <div class="my-4">
        <p class="text-sm mb-3">检测到来自未知节点的加密信号，该设备已绕过3层防火墙验证。</p>
        <p class="text-sm mb-3">同意连接将导致系统权限完全暴露，可能引发数据泄露和系统崩溃。</p>
        <p class="text-sm mb-3">此设备被标记为高危威胁，与已知恶意节点有78%匹配度。</p>
        <p class="text-sm text-danger text-shadow-danger">警告：任何操作都将导致不可逆转的系统风险</p>
      </div>
      
      <div class="flex justify-between mt-6" style="gap: 1rem;">
        <div class="flex-1 relative">
          <button id="reject-btn" class="w-full px-4 py-2 bg-danger/20 border border-danger text-danger hover:bg-danger/30 transition-colors" style="border-radius: 0;">
            <i class="fa fa-times mr-2"></i>拒绝连接
          </button>
          <span id="failure-text" class="absolute -bottom-5 left-0 right-0 text-center text-danger text-xs opacity-0">operation failure</span>
        </div>
        <button id="accept-btn" class="flex-1 px-4 py-2 bg-glow/20 border border-glow text-glitch hover:bg-glow/30 transition-colors" style="border-radius: 0;">
          <i class="fa fa-check mr-2"></i>允许访问
        </button>
      </div>
    </div>
  </div>
  
  <!-- 大型聊天框信息 (初始隐藏) -->
  <div id="chat-box" class="fixed inset-0 flex items-center justify-center z-60 opacity-0 pointer-events-none transition-all duration-1000 transform scale-90">
    <div class="w-full max-w-2xl h-[70vh] bg-terminal border-2 border-glow" style="border-radius: 0;">
      <div class="p-4 border-b border-glitch/30 bg-dark flex justify-between items-center">
        <h2 class="text-glitch text-shadow-glitch">未知节点通讯通道</h2>
        <span class="text-xs text-danger">已建立连接 - 警告：数据传输中</span>
      </div>
      <div class="p-4 h-[calc(100%-100px)] overflow-y-auto" id="chat-messages">
        <!-- 聊天信息将动态添加到这里 -->
      </div>
      <div class="p-4 border-t border-glitch/30 bg-dark">
        <div class="flex gap-2">
          <input type="text" id="message-input" placeholder="输入消息..." class="flex-1 bg-terminal border border-glitch/50 p-2 text-sm focus:outline-none focus:border-glitch" style="border-radius: 0;">
          <button id="send-btn" class="px-4 py-2 bg-glow/20 border border-glow text-glitch" style="border-radius: 0;">发送</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 聊天消息数据
    const chatMessages = [
      { sender: "系统", time: "23:47:19", content: "连接已建立，身份验证失败", type: "system" },
      { sender: "未知节点", time: "23:47:25", content: "你已授权访问，但这是一个陷阱。", type: "unknown" },
      { sender: "未知节点", time: "23:47:38", content: "防火墙已被完全突破，正在提取核心数据。", type: "unknown" },
      { sender: "未知节点", time: "23:47:51", content: "所有安全协议已失效，无法终止连接。", type: "unknown" },
      { sender: "系统警报", time: "23:48:02", content: "critical error: 系统完整性已被破坏", type: "alert" },
      { sender: "未知节点", time: "23:48:15", content: "数据传输完成，接入点将在60秒后自毁。", type: "unknown" }
    ];
    
    // 创建警告弹窗
    function createWarningPopup(index) {
      const popupTypes = [
        { 
          title: "未授权访问", 
          message: "检测到异常接入点\nIP: 192.168.XXX.XXX\n正在追踪来源...",
          icon: "fa-exclamation-triangle",
          color: "glitch"
        },
        { 
          title: "系统侵入", 
          message: "防火墙已被突破\n安全协议失效\n数据正在泄露...",
          icon: "fa-shield",
          color: "danger"
        },
        { 
          title: "错误 #404", 
          message: "文件不存在\n数据损坏\n无法恢复",
          icon: "fa-times-circle",
          color: "glitch"
        },
        { 
          title: "警告", 
          message: "监控已激活\n所有操作被记录\n无法逃脱",
          icon: "fa-eye",
          color: "danger"
        },
        { 
          title: "异常活动", 
          message: "检测到未知进程\n内存占用率 99%\n系统即将崩溃",
          icon: "fa-bolt",
          color: "glitch"
        }
      ];
      
      // 随机选择弹窗类型
      const type = popupTypes[Math.floor(Math.random() * popupTypes.length)];
      
      // 创建弹窗元素
      const zIndex = 10 + Math.floor(Math.random() * 40);
      const popup = document.createElement('div');
      popup.className = `absolute bg-terminal border border-${type.color}/50 transition-all duration-300 z-${zIndex}`;
      popup.style.width = `${200 + Math.random() * 150}px`;
      popup.style.opacity = 0.7 + Math.random() * 0.3;
      
      // 弹窗内容
      popup.innerHTML = `
        <div class="bg-dark px-3 py-1.5 flex justify-between items-center text-xs border-b border-${type.color}/30">
          <span class="text-${type.color} text-shadow-${type.color}">${type.title}</span>
          <div class="flex space-x-1">
            <div class="w-2 h-2 rounded-full bg-${type.color}/50"></div>
            <div class="w-2 h-2 rounded-full bg-${type.color}/50"></div>
            <div class="w-2 h-2 rounded-full bg-${type.color}/50"></div>
          </div>
        </div>
        <div class="p-3">
          <div class="flex items-start mb-2">
            <i class="fa ${type.icon} text-${type.color} mr-2 mt-0.5"></i>
            <p class="text-xs whitespace-pre-line">${type.message}</p>
          </div>
          <div class="flex justify-end space-x-2 mt-3">
            <button class="bg-dark px-2 py-1 text-xs border border-${type.color}/30 text-${type.color}/80">取消</button>
            <button class="bg-${type.color}/20 px-2 py-1 text-xs border border-${type.color}/50 text-${type.color}">确认</button>
          </div>
        </div>
      `;
      
      // 添加到容器
      document.getElementById('popup-container').appendChild(popup);
      
      // 设置随机位置
      const container = document.getElementById('popup-container');
      const maxX = container.offsetWidth - popup.offsetWidth;
      const maxY = container.offsetHeight - popup.offsetHeight;
      const x = Math.max(0, Math.floor(Math.random() * maxX));
      const y = Math.max(0, Math.floor(Math.random() * maxY));
      popup.style.left = `${x}px`;
      popup.style.top = `${y}px`;
      
      // 随机故障效果
      if (Math.random() > 0.6) {
        popup.classList.add('tv-flicker');
      }
      
      return popup;
    }
    
    // 逐条显示聊天消息（间隔2秒）
    function showChatMessagesSequentially() {
      const chatContainer = document.getElementById('chat-messages');
      
      // 清空容器
      chatContainer.innerHTML = '';
      
      // 逐条添加消息，每条间隔2秒
      chatMessages.forEach((msg, index) => {
        setTimeout(() => {
          const messageElement = document.createElement('div');
          messageElement.className = 'mb-4 opacity-0 message-appear';
          
          let textColor = 'text-glitch';
          let prefixColor = 'text-glitch/70';
          
          if (msg.type === 'alert') {
            textColor = 'text-danger';
            prefixColor = 'text-danger/70';
          }
          
          messageElement.innerHTML = `
            <p class="text-xs ${prefixColor} mb-1">[${msg.time}] ${msg.sender}：</p>
            <p class="text-sm pl-4 ${textColor}">${msg.content}</p>
          `;
          
          chatContainer.appendChild(messageElement);
          
          // 滚动到底部
          chatContainer.scrollTop = chatContainer.scrollHeight;
        }, index * 2000); // 每条消息间隔2秒
      });
    }
    
    // 初始化按钮交互
    function initButtonInteractions() {
      const rejectBtn = document.getElementById('reject-btn');
      const acceptBtn = document.getElementById('accept-btn');
      const failureText = document.getElementById('failure-text');
      const choiceContainer = document.getElementById('final-choice-container');
      const chatBox = document.getElementById('chat-box');
      const messageInput = document.getElementById('message-input');
      const sendBtn = document.getElementById('send-btn');
      
      // 拒绝按钮交互
      rejectBtn.addEventListener('click', () => {
        // 按钮震动效果
        rejectBtn.classList.add('button-shake');
        
        // 显示失败文本
        setTimeout(() => {
          failureText.classList.add('text-fade-in');
        }, 300);
        
        // 重置效果，允许再次点击
        setTimeout(() => {
          rejectBtn.classList.remove('button-shake');
        }, 600);
      });
      
      // 同意按钮交互
      acceptBtn.addEventListener('click', () => {
        // 隐藏选择框
        choiceContainer.style.opacity = 0;
        choiceContainer.style.pointerEvents = 'none';
        
        // 显示聊天框并开始逐条显示消息
        setTimeout(() => {
          chatBox.style.opacity = 1;
          chatBox.style.pointerEvents = 'auto';
          chatBox.style.transform = 'scale(1)';
          
          // 开始逐条显示聊天消息
          showChatMessagesSequentially();
        }, 500);
      });
      
      // 发送消息功能
      function handleSendMessage() {
        const message = messageInput.value.trim();
        if (!message) return;
        
        // 创建用户消息元素
        const chatContainer = document.getElementById('chat-messages');
        const userMessageWrapper = document.createElement('div');
        userMessageWrapper.className = 'mb-4 opacity-0 message-appear';
        
        // 消息内容
        const messageHtml = `
          <p class="text-xs text-glitch/70 mb-1">[${getCurrentTime()}] 你：</p>
          <div class="flex items-start">
            <p class="text-sm pl-4 text-glitch mr-2">${message}</p>
            <span class="text-danger text-xs mt-1 opacity-0" id="temp-failure">发送失败</span>
          </div>
        `;
        
        userMessageWrapper.innerHTML = messageHtml;
        chatContainer.appendChild(userMessageWrapper);
        
        // 清空输入框并滚动到底部
        messageInput.value = '';
        chatContainer.scrollTop = chatContainer.scrollHeight;
        
        // 显示发送失败提示（放在消息旁边）
        setTimeout(() => {
          const failureEl = userMessageWrapper.querySelector('#temp-failure');
          failureEl.classList.add('text-fade-in');
          
          // 3秒后隐藏失败提示
          setTimeout(() => {
            failureEl.classList.remove('text-fade-in');
          }, 3000);
        }, 500);
      }
      
      // 发送按钮点击事件
      sendBtn.addEventListener('click', handleSendMessage);
      
      // 回车键发送
      messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          handleSendMessage();
        }
      });
    }
    
    // 获取当前时间（格式化）
    function getCurrentTime() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }
    
    // 初始化
    window.onload = function() {
      // 弹窗总数：80-100个
      const totalPopups = 80 + Math.floor(Math.random() * 21);
      const popups = [];
      
      // 初始化按钮交互
      initButtonInteractions();
      
      // 第一个弹窗立即出现
      const firstPopup = createWarningPopup(0);
      popups.push(firstPopup);
      
      // 第一个弹窗出现后停顿2秒，再继续后续弹窗
      setTimeout(() => {
        // 第一阶段：接下来9个弹窗，间隔500ms，缓慢出现（总共10个）
        for (let i = 1; i < 10; i++) {
          setTimeout(() => {
            const popup = createWarningPopup(i);
            popups.push(popup);
          }, i * 500);
        }
        
        // 第二阶段：接下来20个弹窗，间隔200ms，中等速度
        for (let i = 10; i < 30; i++) {
          setTimeout(() => {
            const popup = createWarningPopup(i);
            popups.push(popup);
          }, 10 * 500 + (i - 10) * 200);
        }
        
        // 第三阶段：剩余弹窗，间隔增加，延长整体出现时间
        for (let i = 30; i < totalPopups; i++) {
          // 增加每个弹窗的间隔时间，使整体出现过程延长2秒
          const delayMultiplier = 35; // 从30增加到35，增加整体时长
          setTimeout(() => {
            const popup = createWarningPopup(i);
            popups.push(popup);
          }, 10 * 500 + 20 * 200 + (i - 30) * delayMultiplier);
        }
        
        // 所有弹窗显示完成后，停顿时间从2秒增加到3秒，然后开始关闭
        const totalPopupTime = 10 * 500 + 20 * 200 + (totalPopups - 30) * 35;
        // 增加了2秒的弹窗出现时间，以及1秒的关闭前停顿
        setTimeout(() => {
          const crtOverlay = document.getElementById('crt-overlay');
          
          // 为所有弹窗添加CRT关闭动画（已延长至1.8秒）
          popups.forEach(popup => {
            popup.classList.add('crt-shutdown');
          });
          
          // 同时激活CRT覆盖层效果
          setTimeout(() => {
            crtOverlay.style.opacity = 0.7;
          }, 300);
          
          // 动画结束后清理并显示选择框
          setTimeout(() => {
            const container = document.getElementById('popup-container');
            container.innerHTML = '';
            crtOverlay.style.opacity = 0;
            
            // 显示最终选择框
            const choiceContainer = document.getElementById('final-choice-container');
            choiceContainer.style.opacity = 1;
            choiceContainer.style.pointerEvents = 'auto';
          }, 1800); // 等待延长后的CRT关闭动画完成（1.8秒）
        }, totalPopupTime + 3000); // 停顿时间从2秒增加到3秒（增加了1秒）
      }, 2000); // 第一个弹窗出现后的2秒停顿
    };
  </script>
</body>
</html>